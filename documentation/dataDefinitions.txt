The pseudocode may contain variables.

Because these variables are dynamically allocated their size cannot be known at compile time.
To avoid inefficiencies, they are contained in a B-tree.
The searchable key is the variable name.
Keywords of the language may not be variable names.

The pseudocode contains no unsigned integers.

Every variable is of the type
struct variable
	unsigned char type
	void *contents
	unsigned short refcount

valid types are:
0 - the variable is undefined
1 - the value is an int
2 - the value is a string
3 - the value is on object reference.
4 - the value is a defined function
5 - the value is a class archtype
6 - the value is an array of values

if the var value is a int, the integer value is stored in the pointer.
Be careful not to dereference those!

In the case of a funtion it is a pointer to the beginning of the block
inside the function.

In the case of an array the remaining bits of the info variable contain the length of the array.


The remaining bits store the size of the variable.

Structure of the info number
[bits storing the size] [type bits]

The short refcount contains the number of references to this variable.

The variables B-Tree consists of the following structs:

struct varTreeNode
	char *name
	varTreeNode *left
	varTreeNode *right
	variable *var

There are no string operations aside from comparing.
Comparing is done using the strcomp result syntax:
1 the left variable is larger
0 the variables are equal
-1 the left variable is smaller
-2 one of the variables is undefined
-3 the variables are not of equal type

If both variables are objects, it will eiter return 0
if the pointer addresses are the same (It is just another reference)
or 2 if the adresses are not equal.

Classes are stored in the global namespace, e.g the globalTree
This means they disobey the normal scoping rules.
Once a class is declared it STAYS declared until its declaration is overwritten by another
declaration (not recommended because it invalidates all its objects)
or the program ends

Functions behave in the same way class definitions do. They are also kept in the global namespace
This means that no function and class may have the same name.

The interpreter has an internal variable buffer on the stack it can pass to
the functions.
